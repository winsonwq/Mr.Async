{"name":"Mr.async","body":"# Mr.Async\r\n\r\n## Iterator\r\n\r\n* **asynEach** : function (array, callback, outerFunc)\r\n* **asynIterator** : function (iterator, callback, outerFunc)\r\n* **range** : function (minAndMax)\r\n* **infinite** : function ()\r\n\r\nFirstly, thanks to Jscex library created by Jeffrey Zhao. I realized what the Jscex solve, how Jscex can improve javascript asynchronism. After reading his blog, I have a try my own solution, AsynIterator.\r\n\r\nSuppose there is a array which contains 5 numbers( 1 - 5 ), user want to traverse this array and print the current value each 1 second. DO NOT tell me you will write like below:\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar len = arr.length;\r\nfor(var i = 0 ; i < len ; i++){\r\n    window.setTimeout(function(){\r\n        console.log(i);\r\n    }, 1000);\r\n}\r\n\r\n// output\r\n// 5\r\n// 5\r\n// 5\r\n// 5\r\n// 5\r\n// it's wrong. !\r\n```\r\n\r\nOR\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\nfor(var i = 0 ; i < arr.length ; i++){\r\n    print(arr[i]);\r\n}\r\n\r\nfunction print(i){\r\n    window.setTimeout(function(){\r\n        console.log(i);\r\n    }, 1000);\r\n}\r\n\r\n//output\r\n// 1\r\n// 2\r\n// 3\r\n// 4\r\n// 5\r\n// value is correct, but these values was printed immediately. so it's wrong too.\r\n```\r\n\r\nAnd how to make it right, mostly of us will write code like below:\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar len = arr.length;\r\n(function traverse(arr, idx){\r\n    idx = idx || 0;\r\n    if(idx < len){\r\n        console.log(arr[idx++]);\r\n        setTimeout(function(){  \r\n            traverse(arr, idx);\r\n        }, 1000);\r\n    }\r\n})(arr);\r\n\r\n// output\r\n// 1\r\n// 2\r\n// 3\r\n// 4\r\n// 5\r\n// it's correct, but not easy to understand.  \r\n```\r\n\r\nThe code is too complicated to understand, the problem is how to make code structure like for loop, and how to make the logic clear. Right now, we have Mr.asynIterator function. Example:\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\nMr.asynEach(arr, function(i){\r\n    console.log(i);\r\n    window.setTimeout(this.callback(), 1000);\r\n}).start();\r\n// output\r\n// 1\r\n// 2\r\n// 3\r\n// 4\r\n// 5\r\n// it's absolutely correct. And code structure seems good.\r\n```\r\n\r\nThis just a simple demo for solving asynchronization problem. In addition, if you want to traverse other kinds of object, not a array. you can use Mr.asynIterator function. Mr.range will makes a range with number in a special format, such as \"[1, 10]\" means number 1 to 10. \"(1, 10]\" means 2 to 10. Mr.infinite will make a infinite range which means 1 to âˆž. Example:\r\n\r\n```javascript\r\nMr.asynIterator(Mr.range('[1, 5]'), function(num){\r\n    if(num == 4){\r\n        return Mr.CONTINUE;\r\n    }\r\n    console.log(num);\r\n    window.setTimeout(this.callback(), 1000);\r\n}).start();\r\n// output\r\n// 1\r\n// 2\r\n// 3\r\n// 5\r\n```\r\n\r\nOf course, user can create his own object to be iterated if the object have next function to return the next value. Example:\r\n\r\n```javascript\r\nvar infinite = {\r\n    _cnt : 0,\r\n    next : function(){\r\n        return this._cnt++;\r\n    }\r\n};\r\n        \r\nMr.asynIterator(infinite, function(num){\r\n    console.log(num);\r\n    window.setTimeout(this.callback(), 1000);\r\n}).start();\r\n// output\r\n// 0\r\n// 1\r\n// 2\r\n// 3\r\n// 4\r\n// ...\r\n```\r\n\r\nAt this moment, we can well deal with the asyn problem, but how about nesting iteration. Don't worry, you can follow as below:\r\n\r\n```javascript\r\n// default\r\nfor(var i = 0 ; i < 3 ; i++){\r\n    for(var ii = 0 ; ii < 3 ; ii++){\r\n        console.log(i + ',' + ii);\r\n        // all numbers will be shown at a moment.\r\n    }\r\n}\r\n\r\n// but now, using Mr.asynIterator\r\nMr.asynIterator(Mr.range('[0, 3)'), function(i){\r\n    Mr.asynIterator(Mr.range('[0, 3)'), function(ii){\r\n        console.log(i + ',' + ii);\r\n        window.setTimeout(this.callback(), 1000); // print each second.\r\n    }, this.callback()).start();\r\n}).start();\r\n// output\r\n// 0, 0\r\n// 0, 1\r\n// 0, 2\r\n// 1, 0\r\n// 1, 1\r\n// 1, 2\r\n// 2, 0\r\n// 2, 1\r\n// 2, 2\r\n```\r\n\r\nThe second one seems a little more complicated than the first, but it perform Asynchronously, the first one can nenver do this. AsynIterator object have two member functions call callback and next. In these demo codes, you will find many callback methods have been invoked, the example below show how callback method works. Example:\r\n\r\n```javascript\r\nMr.asynEach([1, 2, 3], function(num){\r\n    console.log(num);\r\n    setTimeout(this.callback(), 1000);\r\n}).start();\r\n\r\nMr.asynEach([1, 2, 3], function(num){\r\n    console.log(num);\r\n    var outer = this;\r\n    setTimeout(function(){ outer.next(); }, 1000);\r\n}).start();\r\n\r\n// the two methods are same.\r\n```\r\n\r\nThis example we can see callback is a wrapper of next, and two method are trying to deal with the next value from iterated object. In addition, callback handler have a function argument which contains the result of asynchronization method.\r\n\r\n```javascript\r\nfunction caculate(num, callback){\r\n    var timespan = Math.random(1) * 1000;\r\n    setTimeout(function(){\r\n        callback(num * num);\r\n    }, timespan);\r\n}\r\n\r\nMr.asynEach([2, 3, 4], function(num){\r\n    caculate(num, this.callback(function(result){\r\n        console.log(result);\r\n    }));\r\n}).start();\r\n// output\r\n// 4\r\n// 9\r\n// 16\r\n```\r\n\r\ncaculate method is a simple asyn method which is usually have a callback argument. By using Mr.asynEach, we can easily get the result of caculation regardless of the caculation time. It's cool. You can visit a advanced demo Selection Sort. (Please choose a browser which support SVG).\r\n\r\n## Mr.Deferred\r\n**_Mr.Deferred : function ()_**\r\n\r\nAccording to CommonJS Promise/A, Mr.Deferred function will return a Deferred object. And a Deferred object always contains these methods:\r\n\r\n  * always : function (alwaysHandler), add always handler.\r\n  * done : function (doneHandler), add done handler.\r\n  * fail : function (failureHandler), add failure handler.\r\n  * then : function (doneHandler, failureHandler), add done handler and failer handler.\r\n  * isRejected : function (), check if rejected.\r\n  * isResolved : function (), check if resolved.\r\n\r\nExample:\r\n\r\n```javascript\r\nfunction asynFn(){\r\n    var dfd = Mr.Deferred();\r\n    setTimeout(function(){\r\n        dfd.resolve(1, 1, 1, 1, 1);\r\n    }, Math.random(1) * 2000);\r\n    setTimeout(function(){\r\n        dfd.reject(2, 2, 2, 2, 2);\r\n    }, Math.random(1) * 2500);\r\n    return dfd.promise();\r\n}\r\n\r\nasynFn()\r\n    .done(function(){\r\n        console.log('done');\r\n        console.log(arguments);\r\n    })\r\n    .fail(function(){\r\n        console.log('fail');\r\n        console.log(arguments);\r\n    })\r\n    .then(\r\n        function(){\r\n            console.log('then->done');\r\n            console.log(arguments);\r\n        }, \r\n        function(){\r\n            console.log('then->fail');\r\n            console.log(arguments);\r\n        })\r\n    .always(function(){\r\n        console.log('always');\r\n        console.log(arguments);\r\n    })\r\n    .then(\r\n        function(){\r\n            console.log('then2->done');\r\n            console.log(arguments);\r\n        }, \r\n        function(){\r\n            console.log('then2->fail');\r\n            console.log(arguments);\r\n        });\r\n\r\n// if succeed, output:\r\n// done\r\n// [1, 1, 1, 1, 1]\r\n// then->done\r\n// [1, 1, 1, 1, 1]\r\n// then2->done\r\n// [1, 1, 1, 1, 1]\r\n// always\r\n// [Object { _doneFns=, more...}] // the deferred object in firebug console.\r\n\r\n// if failure, output:\r\n// fail\r\n// [2, 2, 2, 2, 2]\r\n// then->fail\r\n// [2, 2, 2, 2, 2]\r\n// then2->fail\r\n// [2, 2, 2, 2, 2]\r\n// always\r\n// [Object { _doneFns=, more...}] // the deferred object in firebug console. \r\n```\r\n\r\n## Mr.when\r\n_**Mr.when : function(deferredObj1[, deferredObj2, [deferredObj3, ...]])**_\r\n\r\nWe can use Mr.when function to deal with multiple Deferred objects. \r\n\r\nExample:\r\n\r\n```javascript\r\nfunction asynFn(){\r\n    var dfd = Mr.Deferred();\r\n    setTimeout(function(){\r\n        dfd.resolve(1, 1, 1, 1, 1);\r\n    }, Math.random(1) * 2000);\r\n    setTimeout(function(){\r\n        dfd.reject(2, 2, 2, 2, 2);\r\n    }, Math.random(1) * 2500);\r\n    return dfd.promise();\r\n}\r\n\r\nfunction asynFn2(){\r\n    var dfd = Mr.Deferred();\r\n    setTimeout(function(){\r\n        dfd.resolve(33, 33, 33);\r\n    }, Math.random(1) * 3000);\r\n    return dfd.promise();\r\n}\r\n\r\nMr.when( asynFn(), asynFn2() )\r\n    .done(function(){\r\n        console.log('when:done');\r\n        console.log(arguments);\r\n    })\r\n    .fail(function(){\r\n        console.log('when:fail');\r\n        console.log(arguments);\r\n    })\r\n    .always(function(){\r\n        console.log('when:always');\r\n        console.log(arguments);\r\n    })\r\n    .then(\r\n        function(){\r\n            console.log('when:then->done');\r\n            console.log(arguments);\r\n        },\r\n        function(){\r\n            console.log('when:then->fail');\r\n            console.log(arguments);\r\n        }\r\n    );\r\n\r\n// if succeed, output:\r\n// when:done\r\n// [1, 1, 1, 1, 1, 33, 33, 33]\r\n// when:then->done\r\n// [1, 1, 1, 1, 1, 33, 33, 33]\r\n// when:always\r\n// [Object { _doneFns=, more...}, Object { _doneFns=, more...}] // the two deferred objects in firebug.\r\n```\r\n\r\n## Test\r\n\r\nTested by QUnit, see _/Mr.js/Mr.Async/test/qunit/index.html_ when you clone this library.","tagline":"Async in Mr.js","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}